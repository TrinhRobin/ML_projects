from fastapi import FastAPI, Response, HTTPException
from book import Book,ReviewRequest, damerau_levenshtein_distance
import pandas as pd
import requests
import json 
import numpy as np
app = FastAPI()

# Charger les données  au démarrage de l'application

books_db = pd.read_csv('books.csv')

with open("books_reviews.json", "r") as file:
    book_reviews = json.load(file)

@app.post("/books/")
async def create_book(book: Book):
    global books_db
    books_db = books_db.append(book.dict(), ignore_index=True)
    return {"message": "Livre ajouté avec succès !"}


@app.get("/books/")
async def get_books():
    global books_db
    return  books_db.sample(n=1).fillna('').to_dict(orient="records")


@app.get("/books/{book_id}")
async def get_book(book_id: int):
    global books_db
    if 0 <= book_id < len(books_db):
        return books_db.iloc[book_id].fillna(' ').to_dict()
    return {"error": "Livre non trouvé"}

@app.get(
    "/get_cover/{isbn}",

    # Set what the media type will be in the autogenerated OpenAPI specification.
    # fastapi.tiangolo.com/advanced/additional-responses/#additional-media-types-for-the-main-response
    responses = {
        200: {
            "content": {"image/png": {}}
        }
    },

    # Prevent FastAPI from adding "application/json" as an additional
    # response media type in the autogenerated OpenAPI specification.
    # https://github.com/tiangolo/fastapi/issues/3258
    response_class=Response
)
async def get_book_cover(isbn:int=9780940262836): 
    """
    Récupère la couverture d'un livre à partir de son ISBN en utilisant l'API Google Books.
    
    Args:
        isbn (str): ISBN du livre.
        
    Returns:
        dict: Dictionnaire contenant l'URL de la couverture du livre.
    """
    try:
        response = requests.get(url=f"https://www.googleapis.com/books/v1/volumes?q=isbn:{isbn}")
        data = response.json()
        book_info = data.get("items", [])[0].get("volumeInfo", {})
        
        has_image = book_info.get("readingModes",{}).get("image",None)
        if has_image :
            cover_url = book_info.get("imageLinks", {}).get("thumbnail", None)
            image_response = requests.get(cover_url)
            if image_response.status_code == 200:
                # media_type here sets the media type of the actual response sent to the client.
                return Response(content=image_response.content, media_type="image/png")
            else:
                raise HTTPException(status_code=500, detail="Erreur lors de la récupération de l'image.")
            
        else:
            raise HTTPException(status_code=404, detail="Couverture non trouvée pour cet ISBN.")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur lors de la récupération de la couverture : {str(e)}")
                            

@app.delete("/books/{book_id}")
async def delete_book(book_id: int):
    global books_db
    if 0 <= book_id < len(books_db):
        deleted_book = books_db.iloc[book_id].to_dict()
        books_db = books_db.drop(index=book_id).reset_index(drop=True)
        return {"message": f"Livre '{deleted_book['title']}' supprimé avec succès !"}
    return {"error": "Livre non trouvé"}

@app.get("/search/")
async def search_books(query: str):
    global books_db
    # Recherche le livre le plus proche en utilisant Damerau-Levenshtein distance
    closest_title = min(books_db['Title'], key=lambda x: damerau_levenshtein_distance(query, x))
    closest_book = books_db[books_db['Title'] == closest_title].iloc[0].to_dict()
    return {'closest book' : closest_book, 'score': damerau_levenshtein_distance(query,closest_title)}

@app.post("/reviews")
async def add_review( review: ReviewRequest):
    """
    Ajoute une critique pour un livre basé sur son ISBN.
    
    Args:
        isbn (str): ISBN du livre.
        review (ReviewRequest): Données de la critique (note et commentaire).
        
    Returns:
        JSONResponse: Réponse JSON indiquant si la critique a été ajoutée avec succès.
    """
    isbn = review.book.isbn 
    if isbn in book_reviews:
        book_reviews[isbn].append({"rating": review.rating, "comment": review.comment})
    else:
        book_reviews[isbn] = [{"rating": review.rating, "comment": review.comment}]

    # Enregistrez les données mises à jour dans le fichier JSON
    with open("books_reviews.json", "w") as file:
        json.dump(book_reviews, file)
    
    return {"message": "Critique ajoutée avec succès."}

@app.get("/reviews/{isbn}")
async def get_reviews(isbn: str):
    """
    Récupère les critiques d'un livre basé sur son ISBN.
    
    Args:
        isbn (str): ISBN du livre.
        
    Returns:
        List[dict]: Liste des critiques du livre avec des notes et des commentaires.
    """
    if isbn in book_reviews:
        reviews_data = book_reviews[isbn]
        ratings = [review["rating"] for review in reviews_data]
        num_reviews = len(ratings)
        mean_rating = np.mean(ratings)
        quantiles = np.percentile(ratings, [25, 50, 75])  # Calcul des quartiles
        
        metadata = {
            "num_reviews": num_reviews,
            "mean_rating": mean_rating,
            "quantiles": {
                "25th_percentile": quantiles[0],
                "median": quantiles[1],
                "75th_percentile": quantiles[2]
            }
        }
        
        response_data = {
            "reviews": reviews_data,
            "metadata": metadata
        }

        return response_data
    else:
        raise HTTPException(status_code=404, detail="Aucune critique trouvée pour cet ISBN.")